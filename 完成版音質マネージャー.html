<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>éŸ³è³ªã‚«ã‚¹ã‚¿ãƒ ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</title>
<style>
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  h1 { margin-bottom: 10px; }
  input, select, button { margin: 5px; padding: 8px; font-size: 1em; }
  audio { margin-top: 15px; width: 100%; }
  hr { margin-top: 30px; }
  #footer { text-align:center; margin-top:20px; font-family:sans-serif; }
  #footer img { border-radius:50%; width:80px; }
</style>
</head>
<body>
<h1>ğŸ§ éŸ³è³ªã‚«ã‚¹ã‚¿ãƒ ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</h1>

<!-- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ -->
<input type="file" id="audioFile" accept="audio/*"><br>

<!-- ãƒ¢ãƒ¼ãƒ‰é¸æŠ -->
<select id="modeSelect">
  <option value="normal">é€šå¸¸</option>
  <option value="low">éŸ³è³ªã‚’æ‚ªã</option>
  <option value="radio">ãƒ©ã‚¸ã‚ªé¢¨</option>
  <option value="loud">çˆ†éŸ³ãƒ¢ãƒ¼ãƒ‰</option>
</select>

<!-- å¼·ã•ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ -->
<label>å¼·ã•: <input type="range" id="strength" min="0" max="100" value="50"></label><br>

<!-- æ›´æ–°ãƒœã‚¿ãƒ³ -->
<button id="updateButton">ğŸ”„ æ›´æ–°</button>
<!-- å†ç”Ÿãƒœã‚¿ãƒ³ -->
<button id="playButton">â–¶ï¸ å†ç”Ÿ</button>
<!-- ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼†å…±æœ‰ -->
<button id="downloadButton">ğŸ’¾ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
<button id="shareButton">ğŸ“¤ å…±æœ‰</button>

<!-- å†ç”Ÿãƒãƒ¼ -->
<div id="playerContainer"></div>

<hr>

<!-- è£½ä½œè€…ã¨ã‚¢ã‚¤ã‚³ãƒ³ -->
<div id="footer">
  <img src="https://i.ibb.co/cKFNWtj5/thinker.png" alt="è€ƒãˆã‚‹äººã‚¢ã‚¤ã‚³ãƒ³"><br>
  <p>è£½ä½œè€…: kakeru</p>
</div>

<script>
let audioContext;
let originalBuffer = null;
let processedBuffer = null;

// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
document.getElementById("audioFile").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const arrayBuffer = await file.arrayBuffer();
  audioContext = new AudioContext();
  originalBuffer = await audioContext.decodeAudioData(arrayBuffer);
  processedBuffer = originalBuffer;
  alert("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼");
});

// æ›´æ–°ï¼ˆå†åŠ å·¥ï¼‰
document.getElementById("updateButton").addEventListener("click", async () => {
  if (!originalBuffer) {
    alert("ã¾ãšéŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã­ï¼");
    return;
  }
  const mode = document.getElementById("modeSelect").value;
  const strength = document.getElementById("strength").value;
  processedBuffer = await processAudio(originalBuffer, mode, strength);
  alert("è¨­å®šã‚’åæ˜ ã—ã¾ã—ãŸï¼");
});

// å†ç”Ÿãƒœã‚¿ãƒ³
document.getElementById("playButton").addEventListener("click", () => {
  if (!processedBuffer) {
    alert("ã¾ãšãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ï¼");
    return;
  }

  const container = document.getElementById("playerContainer");
  container.innerHTML = ""; // å¤ã„ãƒãƒ¼å‰Šé™¤
  const audio = document.createElement("audio");
  audio.controls = true;
  audio.src = URL.createObjectURL(audioBufferToWavBlob(processedBuffer));
  container.appendChild(audio);
  audio.play();
});

// ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
document.getElementById("downloadButton").addEventListener("click", () => {
  if (!processedBuffer) {
    alert("ã¾ã éŸ³å£°ãŒã‚ã‚Šã¾ã›ã‚“ï¼");
    return;
  }
  const wavBlob = audioBufferToWavBlob(processedBuffer);
  const link = document.createElement("a");
  link.href = URL.createObjectURL(wavBlob);
  link.download = "processed_audio.wav";
  link.click();
});

// å…±æœ‰ãƒœã‚¿ãƒ³
document.getElementById("shareButton").addEventListener("click", async () => {
  if (!processedBuffer) {
    alert("ã¾ã éŸ³å£°ãŒã‚ã‚Šã¾ã›ã‚“ï¼");
    return;
  }

  const wavBlob = audioBufferToWavBlob(processedBuffer);
  const file = new File([wavBlob], "processed_audio.wav", { type: "audio/wav" });

  if (navigator.canShare && navigator.canShare({ files: [file] })) {
    await navigator.share({
      files: [file],
      title: "åŠ å·¥ã—ãŸéŸ³ã‚’ãƒã‚§ãƒƒã‚¯ï¼",
      text: "éŸ³è³ªã‚’ã‚«ã‚¹ã‚¿ãƒ ã—ãŸéŸ³å£°ã ã‚ˆğŸ¶"
    });
  } else {
    const link = document.createElement("a");
    link.href = URL.createObjectURL(wavBlob);
    link.download = "processed_audio.wav";
    link.click();
  }
});

// éŸ³åŠ å·¥é–¢æ•°
async function processAudio(buffer, mode, strength) {
  const offline = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
  const src = offline.createBufferSource();
  src.buffer = buffer;

  let gain = offline.createGain();
  let filter = offline.createBiquadFilter();

  switch (mode) {
    case "low":
      filter.type = "lowpass";
      filter.frequency.value = 1000 - strength * 8;
      gain.gain.value = 1;
      break;
    case "radio":
      filter.type = "bandpass";
      filter.frequency.value = 2000;
      filter.Q.value = 1 + strength / 30;
      gain.gain.value = 1;
      break;
    case "loud":
      filter.type = "highshelf";
      filter.frequency.value = 3000;
      filter.gain.value = 10;
      gain.gain.value = 1 + strength / 50;
      break;
    default:
      filter.type = "allpass";
      gain.gain.value = 1;
  }

  src.connect(filter).connect(gain).connect(offline.destination);
  src.start(0);
  return await offline.startRendering();
}

// AudioBuffer â†’ WAV
function audioBufferToWavBlob(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const bufferArray = new ArrayBuffer(length);
  const view = new DataView(bufferArray);
  const channels = [];
  const sampleRate = buffer.sampleRate;
  let offset = 0;

  writeUTFBytes(view, offset, "RIFF"); offset += 4;
  view.setUint32(offset, 36 + buffer.length * numOfChan * 2, true); offset += 4;
  writeUTFBytes(view, offset, "WAVE"); offset += 4;
  writeUTFBytes(view, offset, "fmt "); offset += 4;
  view.setUint32(offset, 16, true); offset += 4;
  view.setUint16(offset, 1, true); offset += 2;
  view.setUint16(offset, numOfChan, true); offset += 2;
  view.setUint32(offset, sampleRate, true); offset += 4;
  view.setUint32(offset, sampleRate * 2 * numOfChan, true); offset += 4;
  view.setUint16(offset, numOfChan * 2, true); offset += 2;
  view.setUint16(offset, 16, true); offset += 2;
  writeUTFBytes(view, offset, "data"); offset += 4;
  view.setUint32(offset, buffer.length * numOfChan * 2, true); offset += 4;

  for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));
  let interleaved = interleave(channels[0], channels[1] || channels[0]);
  for (let i = 0; i < interleaved.length; i++, offset += 2) {
    const s = Math.max(-1, Math.min(1, interleaved[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }

  return new Blob([view], { type: "audio/wav" });

  function interleave(inputL, inputR) {
    const length = inputL.length + inputR.length;
    const result = new Float32Array(length);
    let index = 0, inputIndex = 0;
    while (index < length) {
      result[index++] = inputL[inputIndex];
      result[index++] = inputR[inputIndex++];
    }
    return result;
  }

  function writeUTFBytes(view, offset, string) {
    for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
  }
}
</script>
</body>
</html>